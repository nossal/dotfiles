#!/usr/bin/env bash
set -euo pipefail
# autoinstall: sh "$(curl -fsL https://noss.al/dot)"

DOTFILES_HOME="$HOME/.dotfiles"
LOCAL_BIN_DIR="$HOME/.local/bin"

export DOTDIR="$DOTFILES_HOME"

REPO="https://github.com/nossal/dotfiles"

# declare -A CONFIG=(
#   ["os_manage"]=1
#   ["shell"]="Shell configuration files"
#   ["editor"]="Editor configuration files"
# )

function has() {
  local callable="$1"
  shift

  if declare -f "$callable" >/dev/null 2>&1; then
    "$callable" "$@"
    return $?
  fi

  command -v "$callable" 1>/dev/null 2>&1
}

function install_from_gh() {
  # Downloads and installs a binary from GitHub releases
  #
  # This function downloads a release from GitHub, extracts it, and installs
  # the binary to $LOCAL_BIN_DIR. It supports different naming conventions
  # and archive formats commonly used in GitHub releases.
  #
  # Arguments:
  #   $1 - GitHub repository (e.g., "charmbracelet/gum")
  #   $2 - Version (e.g., "0.11.0")
  #   $3 - Binary name (e.g., "gum")
  #   $4 - Kernel (e.g., "darwin", "linux")
  #   $5 - Architecture (e.g., "amd64", "arm64")
  #   $6 - Archive format (optional, defaults to "tar.gz")
  #
  # Example:
  #   install_from_gh "charmbracelet/gum" "0.11.0" "gum" "darwin" "arm64"
  #
  local repo="$1"
  local version="$2"
  local binary="$3"
  local kernel="$4"
  local arch="$5"
  local format="${6:-tar.gz}"

  local name="${binary}_${version}_${kernel}_${arch}"
  local url="https://github.com/${repo}/releases/download/v${version}/${name}.${format}"
  local tmp_dir="$(mktemp -d)"
  local archive="$tmp_dir/${binary}.${format}"

  echo "Installing ${binary} v${version} for ${kernel}/${arch}..."

  # Download the release
  if ! curl -s -L "$url" -o "$archive"; then
    echo "Failed to download from $url"
    rm -rf "$tmp_dir"
    return 1
  fi

  # Extract based on format
  case "$format" in
    "tar.gz"|"tgz")
      if ! tar -xzf "$archive" -C "$tmp_dir"; then
        echo "Failed to extract archive"
        rm -rf "$tmp_dir"
        return 1
      fi
      ;;
    "zip")
      if ! unzip -q "$archive" -d "$tmp_dir"; then
        echo "Failed to extract archive"
        rm -rf "$tmp_dir"
        return 1
      fi
      ;;
    *)
      echo "Unsupported archive format: $format"
      rm -rf "$tmp_dir"
      return 1
      ;;
  esac

  # Find and copy the binary
  if [ -f "$tmp_dir/${name}/${binary}" ]; then
    cp "$tmp_dir/${name}/${binary}" "$LOCAL_BIN_DIR/"
  elif [ -f "$tmp_dir/${binary}" ]; then
    cp "$tmp_dir/${binary}" "$LOCAL_BIN_DIR/"
  else
    echo "Could not find binary in extracted archive"
    rm -rf "$tmp_dir"
    return 1
  fi

  # Cleanup
  rm -rf "$tmp_dir"
  echo "${binary} v${version} installed successfully to $LOCAL_BIN_DIR"
}

function install() {
  local cmd="$1"
  local name="${2:-$cmd}"
  has "$cmd" || {
    echo "Installing $name..."
    setup
  } && {
    echo "$name is already installed."
    has update && update
  }
  return 0
}

function _shell() {
  if command -v zsh &> /dev/null; then
    # [[ ! $SHELL == *"/zsh" ]] && chsh -s /bin/zsh
    echo "zsh"
  else
    echo "bash"
  fi
}
shell="$(_shell)"

function is_wsl() {
  IFS='-' read -r _ sub rest <<< "$(uname -r)"
  [ "$sub" == "microsoft" ] && echo true
}

function username() {
  if [ "$(is_wsl)" = true ]; then
    echo "$(powershell.exe '$env:UserName' | sed -e 's/\r//g')"
    return
  fi
  echo "$USER"
}

function os_name() {
  case "$(uname -o)" in
    "GNU/Linux")
      local name
      # echo "It\`s Linux, baby!"
      name="$(awk -F= '$1=="ID" { print $2 }' /etc/os-release)"
      [ "$(is_wsl)" = true ] && name="$name-wsl"

      echo "$name"
      ;;
    "Darwin")
      # echo "Is\`s a Mac, man!"
      echo "mac"
      ;;
    "Msys")
      echo "msys2"
      ;;
    *)
      # echo "I dont\`t know"
      echo ""
      ;;
  esac
}

function config_get() {
  # Get a specific key value from a TOML section
  #
  # Arguments:
  #   $1 - TOML file path
  #   $2 - Section name
  #   $3 - Key name
  #
  # Returns:
  #   The value of the key (without quotes), or empty if not found
  #
  local file="$1"
  local section="$2"
  local key="$3"

  [ ! -f "$file" ] && return 1

  awk -v section="$section" -v key="$key" '
    BEGIN { in_section = 0; found = 0 }

    # Skip comments and empty lines
    /^[[:space:]]*#/ || /^[[:space:]]*$/ { next }

    # Section headers
    /^\[.*\]$/ {
      gsub(/^\[|\]$/, "")
      in_section = ($0 == section)
      next
    }

    # Key-value pairs in target section
    in_section && /=/ {
      eq_pos = index($0, "=")
      current_key = substr($0, 1, eq_pos - 1)
      value = substr($0, eq_pos + 1)

      # Clean key and value
      gsub(/^[[:space:]]*"|"[[:space:]]*$/, "", current_key)
      gsub(/^[[:space:]]*"|"[[:space:]]*$/, "", value)
      gsub(/^[[:space:]]*|[[:space:]]*$/, "", current_key)
      gsub(/^[[:space:]]*|[[:space:]]*$/, "", value)

      if (current_key == key) {
        print value
        found = 1
        exit
      }
    }

    END { exit (found ? 0 : 1) }
  ' "$file"
}

function config_set() {
  # Set a key-value pair in a TOML section
  # Creates the section if it doesn't exist
  # Updates the key if it exists, adds it if it doesn't
  #
  # Arguments:
  #   $1 - TOML file path
  #   $2 - Section name
  #   $3 - Key name
  #   $4 - Value
  #
  local file="$1"
  local section="$2"
  local key="$3"
  local value="$4"
  local temp_file

  # Create file if it doesn't exist
  [ ! -f "$file" ] && touch "$file"

  temp_file="$(mktemp)"

  awk -v section="$section" -v key="$key" -v value="$value" '
    BEGIN {
      in_section = 0
      section_found = 0
      key_updated = 0
      section_ended = 0
    }

    # Section headers
    /^\[.*\]$/ {
      current_section = $0
      gsub(/^\[|\]$/, "", current_section)

      if (current_section == section) {
        in_section = 1
        section_found = 1
        section_ended = 0
        print $0
      } else {
        if (in_section && !key_updated) {
          # Add key before leaving section
          printf "\"%s\" = \"%s\"\n", key, value
          key_updated = 1
        }
        in_section = 0
        section_ended = 1
        print $0
      }
      next
    }

    # Key-value pairs
    /=/ {
      if (in_section) {
        eq_pos = index($0, "=")
        current_key = substr($0, 1, eq_pos - 1)

        # Clean current key
        gsub(/^[[:space:]]*"|"[[:space:]]*$/, "", current_key)
        gsub(/^[[:space:]]*|[[:space:]]*$/, "", current_key)

        if (current_key == key) {
          printf "\"%s\" = \"%s\"\n", key, value
          key_updated = 1
        } else {
          print $0
        }
      } else {
        print $0
      }
      next
    }

    # All other lines
    {
      if (in_section && /^[[:space:]]*$/ && !key_updated) {
        # Empty line in section, good place to add key
        printf "\"%s\" = \"%s\"\n", key, value
        key_updated = 1
        print $0
      } else {
        print $0
      }
    }

    END {
      # If section was never found, create it
      if (!section_found) {
        if (NR > 0) print ""  # Add blank line before new section
        printf "[%s]\n", section
        printf "\"%s\" = \"%s\"\n", key, value
      }
      # If section was found but key was never added
      else if (!key_updated) {
        printf "\"%s\" = \"%s\"\n", key, value
      }
    }
  ' "$file" > "$temp_file"

  mv "$temp_file" "$file"
}


function filter() {
  local section=$1
  local file=$2
  local found=false

  while IFS= read -r line; do
    # Check if the line contains the section name
    if [[ "$line" == "["*"$section"*"]" ]]; then
      found=true
      continue  # Skip printing the section name
    fi
    if [[ "$line" != "["*"$section"*"]" && "$line" == "["* ]]; then
      found=false
      continue  # Skip printing the section name
    fi

    # If the section is found, print the line
    if [ "$found" = true ]; then
      echo "$line"
    fi
  done < "$file"
}

function config_list_keys() {
  # List all keys in a specific TOML section
  #
  # Arguments:
  #   $1 - TOML file path
  #   $2 - Section name
  #
  local file="$1"
  local section="$2"

  [ ! -f "$file" ] && return 1

  awk -v section="$section" '
    BEGIN { in_section = 0 }

    # Skip comments and empty lines
    /^[[:space:]]*#/ || /^[[:space:]]*$/ { next }

    # Section headers
    /^\[.*\]$/ {
      gsub(/^\[|\]$/, "")
      in_section = ($0 == section)
      next
    }

    # Key-value pairs in target section
    in_section && /=/ {
      eq_pos = index($0, "=")
      key = substr($0, 1, eq_pos - 1)

      # Clean key
      gsub(/^[[:space:]]*"|"[[:space:]]*$/, "", key)
      gsub(/^[[:space:]]*|[[:space:]]*$/, "", key)

      print key
    }
  ' "$file"
}

function symlink_configs() {
  # Creates symbolic links for configuration files based on profile and category
  #
  # This function reads a configuration file (links.txt) and creates symbolic links
  # from dotfiles to their target locations in the home directory. It supports:
  #   - Different profiles (e.g., personal, work)
  #   - Categories of configurations (e.g., default, shell, editor)
  #   - Automatic creation of target directories
  #
  # Arguments:
  #   $2 - Category name (optional, defaults to "default")
  #   $2 - Profile name (optional, e.g., "personal", "work")
  #
  # Configuration file format (links.txt):
  #   [default]
  #   nvim/init.lua .config/nvim/init.lua
  #   [shell]
  #   zsh/zshrc .zshrc
  #
  echo "Setting up configuration links"
  local category="${1:-default}"
  local profile="${2:-}"

  # Construct config file path based on profile
  [ -n "$profile" ] && profile="-$profile"
  local config_file="$DOTFILES_HOME/links$profile.toml"
  echo "> Using config file: $config_file"

  # Check if config file exists
  if [ ! -f "$config_file" ]; then
    echo "Configuration file not found: $config_file"
    return
  fi

  # Process each line in the configuration file
  while IFS= read -r source_path; do
    # IFS=' ' read -r source_path target_path <<< "$line"
    local target_path
    target_path=$(config_get "$config_file" "$category" "$source_path")

    [ -z "$target_path" ] && continue

    local target target_dir
    target="$HOME/$target_path"
    target_dir="$(dirname "$target")"

    # Create target directory if it doesn't exist
    [ ! -d "$target_dir" ] && mkdir -p "$target_dir"

    # Create symbolic link if it doesn't exist
    if [ ! -L "$target" ]; then
      ln -sf "$DOTFILES_HOME/$source_path" "$target"
      echo "Created link: $target -> $DOTFILES_HOME/$source_path"
    else
      echo "Link already exists: $target"
    fi
  # done <<< "$(filter "$category" "$config_file")"
  done <<< "$(config_list_keys "$config_file" "$category")"
}

function clean() {
  echo "FIX"
  broken_links=$(find "$HOME" -maxdepth 2 -type l ! -exec test -e {} \; -print 2> /dev/null)
  if [ -n "$broken_links" ]; then
    echo  -e "Removing broken synlinks:\n$broken_links"
    echo "$broken_links" | xargs rm
  fi
}

function tools() {
  # Searches and executes setup files in dotfiles directory
  #
  # This function iterates through all first-level directories in $DOTFILES_HOME,
  # searching for 'setup' files. When found, it ensures they are executable and
  # runs them with two standard parameters:
  #   $DOTFILES_HOME - The root directory of dotfiles
  #   $LOCAL_BIN_DIR - The user's local bin directory
  #
  # Example setup file location:
  #   $DOTFILES_HOME/
  #   ├── neovim/
  #   │   └── setup    # This will be executed
  #   └── zsh/
  #       └── setup    # This will be executed too
  #
  echo "TOOLS"

  while IFS= read -r setup_path; do
    name="$(basename "$(dirname "$setup_path")")"
    echo "Setup $name"
    [ ! -x "$setup_path" ] && chmod u+x "$setup_path"

    "$setup_path"

  done <<< "$(find "$DOTFILES_HOME" -maxdepth 2 -type f -name "setup")"
}

function dot_update() {
  echo "UPDATE"
  cd "$DOTFILES_HOME" && git pull
  dot_install
}

function dot_install() {
  echo "INSTALL"
  clean
  symlink_configs "$@"
  symlink_configs "$@" "$shell"
  tools
}

function bootstrap() {
  # Bootstraps the dotfiles installation process
  #
  # This function handles the initial setup and installation of dotfiles:
  #   1. Checks if git is installed (required for cloning)
  #   2. If dotfiles exist:
  #      - Updates existing installation
  #   3. If dotfiles don't exist:
  #      - Clones the repository to $DOTFILES_HOME
  #   4. Ensures $LOCAL_BIN_DIR exists and is in PATH
  #   5. Executes OS-specific setup if available
  #   6. Runs the installation process
  #
  # Arguments:
  #   $@ - Additional arguments passed to dot_install
  #
  # Example:
  #   bootstrap personal  # Installs dotfiles with 'personal' profile
  #   bootstrap          # Installs dotfiles with default profile

  # check basic os. requirements
  if ! has git; then
    echo "git is required to bootstrap the dotfiles."
    exit 1
  fi

  # check if the dotfiles are already installed
  # if [ -d "$DOTFILES_HOME" ]; then
  #   echo "Dotfiles already installed. Updating..."
  #   dot_update
  # else
  #   git clone "$REPO" "$DOTFILES_HOME"
  # fi

  [ ! -e "$LOCAL_BIN_DIR" ] && \
    mkdir -p "$LOCAL_BIN_DIR"
  [[ ! "$PATH" == *"$LOCAL_BIN_DIR"* ]] && \
    export PATH="$LOCAL_BIN_DIR:$PATH"

  local os
  os="$(os_name)"

  # install charmbracelet/gum if not present
  install_from_gh "charmbracelet/gum" "0.16.2" "gum" "$(uname -o)" "$(uname -m)" "tar.gz"

  # ask to manage the OS
  # read -r -p "Do you want to manage the OS ($os)? [y/N] " response
  # if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
  #   os_setup="$DOTFILES_HOME/os/$os/setup
  #
  local os_setup
  os_setup="$DOTFILES_HOME/os/$os/setup"

  [ -f "$os_setup" ] && \
    "$os_setup" "$DOTFILES_HOME" "$LOCAL_BIN_DIR"

  echo "BOOT"
  dot_install "$@"
}

function usage() {
  # Displays the help message with usage instructions
  #
  # This function prints a formatted help message that includes:
  #   - Basic usage syntax
  #   - Available options
  #   - All available commands with descriptions
  #   - Examples of common use cases
  #
  cat << 'EOF'
    Usage: dot [OPTIONS] [COMMAND] [PROFILE]

    Options:
    -h, --help      Show this help message
    -r, --repo      Specify the repository URL (default: $REPO)

    Commands:
    update          Update existing dotfiles installation
    fix             Fix broken symbolic links
    links [PROFILE] Create symbolic links for dotfiles (optionally with a profile)
    tools           Search and execute setup files in dotfiles directories

    Examples:
    dot                # Bootstrap with default profile
    dot personal       # Bootstrap with personal profile
    dot -r <url>       # Bootstrap from a different repository
    dot update         # Update existing installation
    dot links work     # Create symbolic links for work profile

    For more information, visit: https://github.com/nossal/dotfiles
EOF
}

function main() {
  local command=""
  if [[ $# -eq 0 ]]; then
    command="bootstrap"
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      -r|--repo)
        REPO="$2"
        shift 2
        ;;
      -*)
        error "No option: $1"
        ;;
      *)
        if [[ -z "$command" ]]; then
          command="$1"
        else
          echo "Unexpected argument: $1"
          exit 1
        fi
        shift
        ;;
    esac
  done
  echo "$REPO"

  case "${command}" in
    up|update)
      dot_update
      ;;
    tools)
      tools
      ;;
    fix)
      clean
      ;;
    links)
      symlink_configs "$@"
      ;;
    *)
      bootstrap "$@"
      ;;
  esac
}

# Only run main if script is executed directly (not sourced)
if [[ -n "${BASH_SOURCE:-}" && "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi

